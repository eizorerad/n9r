"""Coverage Analyzer for Test Coverage Integration.

Parses Cobertura XML coverage reports (pytest-cov format) to extract
per-file coverage rates for integration with risk factor calculations.

Requirements: 3.1, 3.2, 3.3
"""

import logging
import xml.etree.ElementTree as ET
from pathlib import Path

logger = logging.getLogger(__name__)


class CoverageAnalyzer:
    """Analyzes test coverage from Cobertura XML reports.

    Parses coverage.xml files generated by pytest-cov to extract
    per-file line coverage rates.

    Requirements: 3.1, 3.3
    """

    # Standard coverage file names to look for
    COVERAGE_FILES = ["coverage.xml", "cov.xml", ".coverage.xml"]

    def __init__(self) -> None:
        pass

    def parse_if_exists(self, repo_path: Path) -> dict[str, float] | None:
        """Parse coverage report if it exists.

        Searches for coverage.xml in the repository root and parses it
        if found. Returns None if no coverage file exists.

        Args:
            repo_path: Path to the repository root

        Returns:
            Dictionary mapping file paths to coverage rates (0.0-1.0),
            or None if no coverage file found

        Requirements: 3.1, 3.3
        """
        coverage_file = self._find_coverage_file(repo_path)

        if coverage_file is None:
            logger.info(f"No coverage file found in {repo_path}")
            return None

        try:
            return self.parse_cobertura_xml(coverage_file)
        except Exception as e:
            logger.warning(f"Failed to parse coverage file {coverage_file}: {e}")
            return None

    def _find_coverage_file(self, repo_path: Path) -> Path | None:
        """Find a coverage file in the repository.

        Args:
            repo_path: Path to the repository root

        Returns:
            Path to coverage file if found, None otherwise
        """
        for filename in self.COVERAGE_FILES:
            coverage_path = repo_path / filename
            if coverage_path.exists():
                logger.info(f"Found coverage file: {coverage_path}")
                return coverage_path

        return None

    def parse_cobertura_xml(self, coverage_file: Path) -> dict[str, float]:
        """Parse a Cobertura XML coverage report.

        Extracts per-file line coverage rates from the XML structure.
        The Cobertura format stores coverage as line-rate attributes
        on class elements.

        Args:
            coverage_file: Path to the coverage.xml file

        Returns:
            Dictionary mapping file paths to coverage rates (0.0-1.0)

        Requirements: 3.1
        """
        coverage_data: dict[str, float] = {}

        try:
            tree = ET.parse(coverage_file)
            root = tree.getroot()

            # Cobertura XML structure:
            # <coverage>
            #   <packages>
            #     <package>
            #       <classes>
            #         <class filename="path/to/file.py" line-rate="0.85">
            #           ...
            #         </class>
            #       </classes>
            #     </package>
            #   </packages>
            # </coverage>

            # Find all class elements with filename and line-rate
            for class_elem in root.iter("class"):
                filename = class_elem.get("filename")
                line_rate_str = class_elem.get("line-rate")

                if filename and line_rate_str:
                    try:
                        line_rate = float(line_rate_str)
                        # Clamp to valid range [0.0, 1.0]
                        line_rate = max(0.0, min(1.0, line_rate))
                        coverage_data[filename] = line_rate
                    except ValueError:
                        logger.warning(
                            f"Invalid line-rate '{line_rate_str}' for {filename}"
                        )

            logger.info(f"Parsed coverage for {len(coverage_data)} files")

        except ET.ParseError as e:
            logger.error(f"XML parse error in {coverage_file}: {e}")
            raise
        except Exception as e:
            logger.error(f"Error parsing coverage file {coverage_file}: {e}")
            raise

        return coverage_data

    def parse_cobertura_xml_string(self, xml_content: str) -> dict[str, float]:
        """Parse Cobertura XML from a string.

        Useful for testing without file I/O.

        Args:
            xml_content: XML content as a string

        Returns:
            Dictionary mapping file paths to coverage rates (0.0-1.0)

        Requirements: 3.1
        """
        coverage_data: dict[str, float] = {}

        try:
            root = ET.fromstring(xml_content)

            for class_elem in root.iter("class"):
                filename = class_elem.get("filename")
                line_rate_str = class_elem.get("line-rate")

                if filename and line_rate_str:
                    try:
                        line_rate = float(line_rate_str)
                        # Clamp to valid range [0.0, 1.0]
                        line_rate = max(0.0, min(1.0, line_rate))
                        coverage_data[filename] = line_rate
                    except ValueError:
                        logger.warning(
                            f"Invalid line-rate '{line_rate_str}' for {filename}"
                        )

        except ET.ParseError as e:
            logger.error(f"XML parse error: {e}")
            raise

        return coverage_data
